Основная структура запроса

SELECT <схема, на которую будет совершена проекция отношения(результата выборки из основного отношения)>
FROM <отношение, к которому будет применена выборка>
WHERE <выборка из отношения предыдущей секции(фильтр)>

порядок выполнения
    FROM - берём отношение
    WHERE выбираем нужные
    SELECT результат - делаем проекцию на нужную схему.


все дальнейшее на примере ученбной базы по ссылке.

Блюда - dishes
Состав - structures
Вид_блюд - dishTypes




FROM
сдесь задаеться отношение, для работы. это может быть одно отношение(имя таблицы),
или отношение, которое является умножением нескольких существующих отношений(таблиц).

FROM dishes
FROM structures
FROM dishes, dishTypes

Всегда для отношения в этой секции можно задать псевдоним спомощью синтаксиса -  AS <псевдоним>
AS - можно опускать

FROM dishes AS d
FROM dishes AS d, dishTypes AS dt, dishes dd

особенно это актуально, если идёт умножение отношения(таблицы) на саму себя несколько раз -
тогда возникает нужда, при работе с атрибутами в кортеже, различать - из какого именно операнда они достались

FROM dishTypes dt1, dishTypes dt2

в результате получим кортежи
{idDishType, dishType, idDishType, dishType} - и при указании атрибута dishType не понятно о каком именно идёт речь
первые два атрибута достаются из первого операнда уножения, вторые из второго.
благодаря псевдонимам
dt1.dishType - сразу ясно о каком именно из двух атрибутов идёт речь.



Что в секции SELECT, что в секции WHERE - для обозначения значения атрибута используется его имя, или
псевдоним.имя - в случае наличия одноименных атрибутов. По умолчанию имя таблицы является ее псевдонимом

FROM dishes
WHERE idDishType = 'C'

FROM dishes AS d
WHERE d.idDishType = 'C'

FROM dishes
WHERE dishes.idDishType = 'C'

FROM dishes
WHERE 'C' = dishes.idDishType

все четыре варианта эквивалентны




WHERE
сдесь мы задаем критерий, через который определяем - нужно или нет включать кортеж в результат.

работу этой секции можно представить логически следующим образом.

FROM dishes
WHERE idDishType = 'C'

похоже на

$dishes = array(...);

$dishesAfterWhere = [];

foreach ($dishes as $item) {
    if ($item['idDishType'] == 'C') {
        $dishesAfterWhere[] = $item;
    }
}


Эта секция осуществляет выборку из отношения по критерию.
FROM - задает целевое отношение
WHERE - применяя условие(критерий) к каждому кортежу, выбирает только те
что подошли под условие(критерий)



SELECT
сдесь задаем схему, куда нажно сделать проекцию результата.

SELECT dishType
FROM dishes
WHERE idDishType = 'C'

Взять все кортежи отношения БЛЮДА, выбрать те, что имеют idDishType С;
и взять проекцию результата на схему {dishType}

получим отношение состоящее из кортежей с одним атрибутом.

В даном случае SELECT dishType задает имя атрибута, начального отношения, значения которого нужно брать
в качестве значений для атрибута результата проекции с именем dishType

Тоесть, в схеме для проекции атрибут называется также как и в начальном отношении. Засчет псевдонимов
атрибут в результате можно назвать иначе.

SELECT dishType as 'atributeName' - dishType -имя атрибута чьи значения берутся для наполнения
значениями атрибута atributeName.

Итого -
SELECT dishType
SELECT dishType as 'anotherName'
дают одинаковый результат по значениям, но с разным названием атрибута результата.
В первом случае, имя атрибута(столбца результата) будет таким же как имя атрибута
в начальном отношении. Во втором случае, он называеться иначе.


Ошибочно мнение, что секция SELECT это выбор части атрибутов.
Это именно проекция. Проекция может и добавлять атрибуты.

SELECT dishType, 10 AS 'addAttributeWithValue10', 'someStringValue' AS 'addStringAttributeWithConstantValue'
FROM dishes

результат - отношение, кортежи которого имеют три атрибута.

изначально кортежи были - например {<idDishType,С> 	<dishType,Суп>}

результат - кортежи с тремя атрибутами

dishType, addAttributeWithValue10, addStringAttributeWithConstantValue

для каждого кортежа начального отношения, будет
1) взят атрибут со значениме dishType
2) добавлен атрибут addAttributeWithValue10 - с значением 10
3) добавлен атрибут addStringAttributeWithConstantValue - с значением someStringValue






